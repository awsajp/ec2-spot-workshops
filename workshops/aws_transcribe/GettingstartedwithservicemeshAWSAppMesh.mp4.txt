the easiest way to get started with service Mesh is with an open source project called superglue from solo dot io. In this video, we're gonna take a look at getting started with AWS at Boesch using superglue Superglue is an A P I abstraction on top of any implementation of service mesh idea with superglue is to simplify the A p I so that we can get consistent behaviour regardless of what What mesh we're actually using SUPERGLUED does other interesting things like allowing us to write extensions to our service mesh without tying to any specific A p. I allows us to manage multiple clusters of a particular implementation of a service nash and allows us to merge or mix and match service mesh implementations as needed. Those will be topics for future videos. In this video, we're gonna show getting started with at mesh. But I want to point you to a log where the good folks that Shopify use superglue to get started with other service mission plantations. I encourage you to take a look at this block. Now let's get to the demo. The first thing we're gonna dio is notice we are you using AWS, we have our e k s cluster spot up here in eight of us. We have our eks cluster. If we come over here to our at mesh Council, we should see we do not have any bash is currently installed. No measures were found. So what we're gonna do is use superglue to register a mesh with Babish. And I said register because ATM issues is a managed control plane. When you use superglue to install other service mesh implementations, we actually install the control plane for those meshes inside our cluster with at fresh, we cannot and do not do that. So the first thing we do is register are at mesh service mesh When a run superbly register at mish, the name we're gonna use is demo that mesh. We're going to store this information in superglue. So this creates a mash CRD which allows superglue to help us track the installation of management of our mesh. We're going to use a secret that allows us to connect to eight of us. We're going to store this with we're gonna create the mess. Where are Eks Cluster is which is in us west to we do want to use sidecar auto injection for this mesh, Which means when we deploy our applications that the auto injector automatically put the sidecar pods. So So the envoy proxies next to our application and configure them to connect to be at Mission Control plates will say yes to that. And we're going to do that for all the pods in the name space. We're going to choose the book info at mesh name space. Obviously done. Now we're gonna we're gonna tell at Mesh or the auto injector to use the default configuration. But we can provide our own configuration if needed. The last thing we'll do is provide a key to the labels that will use to identify what the virtual node names should be. At this point, it should create our mash CRD that superglue knows how to take and managing mesh. If we get the pods in the Super Bowl system, we should see that the auto the sidecar injector has been started and is running. And if you get this message TRD, we should see that it has been created. And lastly, we'll check with at mesh and we should see that our mesh has now been created. If we come back to the console into a refresh here, we should see that it's been created. Demo at Mish. Next, What we're gonna do is we're gonna deploy our book and fill up. If we do get bond book info at MASH, would you say we don't have anything there? So what we're gonna do is set up are looking for app. Watch that that name space, and we will set that up and on the top pain. You'll notice here that the booking flap is deploying and we're seeing two containers per pod, which is exactly what we want to see. This is the auto injector. Putting the sidecar the envoy sidecar proxy and configuring it to talk to to the finish will give us a second to initialize, but in a little farther here. And we are parts of running. Take a look. Is everything up? Everything is up. Great. So that now what we're gonna do. Um, well, not what we're gonna do is take a look at our and are looking for a product page. We see we have the book info, app running. Go into normal user, and we refresh a few times. We should notice that all the traffic in this app, the way we've set it up, is all the traffic is going to the reviewer. The reviews V one version of the service. You know, if you're familiar with booking for Raptor version two and version 31 that shows black stars one that shows red stars. Everything is going to version one right now, and that's fine. But demos from traffic shifting using using at mish. So well, open up the port forwarding again. That should open it. What page again? Scripted demo. Very helpful. Now what we're gonna do is apply some traffic shifting rules. In this case, we're gonna do it in interactive mode. But we could do this with the commandment flags as well. The name of this rule. We're gonna use a split reviews and we're going to put this rule in the superglue system. Though it could live in any of these name spaces were not going to any source. Selectors. For this, we are going to create a destination selected for this, which means any time we talk to the review service, we will enforce this rule a glue and superglue uses something called upstream which is analogous to ah, cluster in Envoy And for this upstream. When we talked to reviews, I will invoke this traffic shifting room and we'll say, done. We don't need to add any more upstream for that. For requests matter, we will add a default request. Bachir will just say a prefix request match your and we just match on. Everything on this could enter. The default is, uh is everything and we do not need to add any other types of matters. Any headers or HCP method will skip that, and we don't need to add another request metric. Next, we're gonna apply this to the superglue at mesh Mesh. Like I said, super Lukin apply traffic rules consistently. This is this is the unified superglue FBI for traffic management on. We can apply this to any mesh, but we'll focus this on now, the upstream that we're going to split traffic to, uh, we're gonna We're gonna split the traffic between reviews V one and reviews V two. We could we could add more, but we're not. We're just gonna stick with those to the weight that will use and split the traffic between V one and V two will be the same. So we should get an even distribution of 50 50 split. Now we see our traffic rule has been created. Traffic shifting rule has been created. And now if we give it a moment when we come back here and start refreshing, we should see that we get traffic shifting approximately. Waited one, the one. Now what we're gonna do is take a look at our traffic rule. We see that this is the Super Bowl, a p I, and it provides a unified way of the spying. Think configurations to a service mesh. In this case at Mish, next thing we're gonna do is do the same traffic shifting. But we're going to do it using command line flags, sort of interactive mode. If you did earlier, we'll just use command line flags to do that. No, you could also do this using the Yamil directly, which is typically what you do with some of these service mesh implementations. Um, with superglue, we have a few different options interactive. We could do it with the family flags or directly with the gavel. Now in this in this example what we're doing is we're splitting the traffic between three different destination back ends, each with the equal weight. This is gonna be for version one or version two were equal late and for version three equal. Uh, actually, version three were doing Ah, wait of five. So we should see version three. Show up more frequently. Inversion to reason with the red Stars than ah than any of the other versions for reviews. And again, we're using AWS at mesh traffic shifting capabilities. But we're using the superglue okay to drive this. If you're interested in superglue, come check it out, superglue dot solo don, I owe if you're interested in APP mesh and aws um, service mesh. Then check out. Check it out of us Concert. Thanks for stopping by this video.